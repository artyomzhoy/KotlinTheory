/** Для всех классов в языке Kotlin родительским суперклассом является класс Any.
 * Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс:
 *
 * class Example // Неявно наследуется от Any
 *
 * У Any есть три метода: equals(), hashCode() и toString(). Эти методы определены для всех классов в Kotlin.
 *
 * По умолчанию все классы в Kotlin имеют статус final, который блокирует возможность наследования.
 * Чтобы сделать класс наследуемым, его нужно пометить ключевым словом open.
 */

open class Base(p: Int) // Класс открыт для наследования

/**
 * Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:
 *
 * Если у класса есть основной конструктор, базовый тип может (и должен) быть проинициализирован там же,
 * с использованием параметров основного конструктора.
 *
 * Суперкласс содержит общие свойства и функции/методы, унаследованные одним или несколькими подклассами.
 *
 * Подкласс может включать дополнительные свойства и функции, а также переопределять аспекты, унаследованные от суперкласса.
 */

class Derived(p: Int) : Base(p)

/** Переопределение методов класса
 *
 * Как упоминалось ранее, мы придерживаемся идеи определённости и ясности в языке Kotlin.
 * Поэтому Kotlin требует явно указывать модификаторы и для членов, которые могут быть переопределены,
 * и для самого переопределения:
 *
 */

open class Shape {
    open fun draw() { /*...*/ }
    fun fill() { /*...*/ }
    open val vertexCount: Int = 0
    
}

class Circle() : Shape() {
    override fun draw() { /*...*/ }
}

/** Для Circle.draw() необходима аннотация override. В случае её отсутствия компилятор выдаст ошибку.
 * Если у функции типа Shape.fill() нет аннотации open, объявление метода с такой же сигнатурой
 * в производном классе невозможно, с override или без.
 * Модификатор open не действует при добавлении к членам final класса (т.е. класса без модификатора open).
 *
 * Член класса, помеченный override, является сам по себе open, т.е. он может быть переопределён в производных классах.
 * Если вы хотите запретить возможность переопределения такого члена, используйте final:
 *
 */

open class Rectangle() : Shape() {
    final override fun draw() { /*...*/ }
}

/** Переопределение свойств класса
 *
 * Переопределение свойств работает также, как и переопределение методов;
 * все свойства, унаследованные от суперкласса, должны быть помечены ключевым словом override,
 * а также должны иметь совместимый тип. Каждое объявленное свойство может быть переопределено свойством
 * с инициализацией или свойством с get-методом.
 */


class Test : Shape() {
    override val vertexCount = 4
}

/** Наследование обеспечивает наличие функций и свойств во всех подклассах, определенных в суперклассе.
 *
 * Если вы определяете набор свойств и функций в суперклассе, эти свойства и функции будут заведомо присутствовать
 * во всех подклассах. Иначе говоря, вы определяете общий протокол, или контракт, для набора классов,
 * связанных наследованием.
 *
 * Полиморфизм означает «много форм». Этот механизм позволяет разным подклассам
 * переопределять разные реализации одной функции.
 */

/** Чтобы объявить класс абстрактным, снабдите его префиксом «abstract».
 *
 * Если класс объявлен абстрактным, это означает, что никто не сможет создавать никакие объекты этого класса,
 * даже если для него определен конструктор.
 *
 * Абстрактный класс может содержать абстрактные и неабстрактные свойства и функции. Абстрактный
 * класс также может не содержать ни одного абстрактного компонента.
 *
 * Абстрактные свойства и функции не обязательно помечать как открытые.
 *
 * Если свойство или функция помечены как абстрактные, класс тоже должен быть помечен как абстрактный.
 * Если класс содержит хотя бы одно абстрактное свойство или функцию, этот класс тоже должен быть помечен как абстрактный,
 * в противном случае код не будет компилироваться.
 *
 * Чтобы реализовать абстрактные свойства и функции, вы переопределяете их. Здесь все происходит так же,
 * как и для конкретных суперклассов.
 */

abstract class Animal {
    abstract val image: String
    abstract val food: String
    abstract val habitat: String
    var hunger = 10
    
    abstract fun makeNoise()
    abstract fun eat()
}

class Hippo : Animal() {
    override val image = "hippo.jpg"
    override val food = "grass"
    override val habitat = "water"
    override fun makeNoise() {
        println("Grunt! Grunt!")
    }
    override fun eat() {
        println("The Hippo is eating $food")
    }
}

/** Интерфейсы похожи на абстрактные классы тем, что вы не можете создавать их экземпляры
 * и они могут определять абстрактные или конкретные функции и свойства. Однако существует одно
 * принципиальное отличие: класс может реализовать несколько интерфейсов, но наследуется только от
 * одного непосредственного суперкласса. Итак, интерфейсы могут предоставлять те же преимущества, что и
 * абстрактные классы, но обладают большей гибкостью.
 *
 * При добавлении абстрактной функции в интерфейс не нужно ставить перед именем функции префикс abstract,
 * как это следовало бы сделать при добавлении абстрактной функции в абстрактный класс.
 * В случае с интерфейсом компилятор автоматически определяет, что функция без тела должна
 * быть абстрактной, поэтому ее не нужно определять как абстрактную.
 *
 * Также в интерфейсы можно добавлять конкретные функции, для этого достаточно определить функцию с телом.
 */

interface Roamable {
    fun roam() // Так определяется абстрактная функция в интерфейсе.
}